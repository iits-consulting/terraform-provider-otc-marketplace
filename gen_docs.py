# Quick and dirty generator for terraform docs
# This should eventually be replaced with `tfplugindocs`, which at the time of writing (19.02.25 at 02:03)
# doesn't support the *Terraform Plugin Framework* but supports the older *Terraform Plugin SDKv2* and
# *Terraform Plugin SDK*.
#
# This script expects to be run in the same directory as "schema.json" generated by:
# `terraform providers schema -json > schema.json`
import json
import os

# Load the schema JSON
with open("schema.json", "r") as f:
    schema = json.load(f)

# Create the docs directory structure
os.makedirs("docs/data-sources", exist_ok=True)
os.makedirs("docs/resources", exist_ok=True)

# Initialize lists to keep track of resources and data sources
resources = []
data_sources = []

# Function to recursively process nested attributes and blocks
def process_attributes(attributes, indent_level=0):
    markdown = ""
    for attr_name, attr_schema in attributes.items():
        # Handle nested types
        if "nested_type" in attr_schema:
            markdown += "  " * indent_level + f"- `{attr_name}` - {attr_schema.get('description', 'No description available.')}\n"
            if attr_schema.get("required", False):
                markdown += "  " * (indent_level + 1) + "(Required)\n"
            elif attr_schema.get("optional", False):
                markdown += "  " * (indent_level + 1) + "(Optional)\n"
            elif attr_schema.get("computed", False):
                markdown += "  " * (indent_level + 1) + "(Computed)\n"
            # Recursively process nested attributes
            markdown += process_attributes(attr_schema["nested_type"]["attributes"], indent_level + 1)
        # Handle regular attributes
        else:
            markdown += "  " * indent_level + f"- `{attr_name}` - {attr_schema.get('description', 'No description available.')}\n"
            if attr_schema.get("required", False):
                markdown += "  " * (indent_level + 1) + "(Required)\n"
            elif attr_schema.get("optional", False):
                markdown += "  " * (indent_level + 1) + "(Optional)\n"
            elif attr_schema.get("computed", False):
                markdown += "  " * (indent_level + 1) + "(Computed)\n"
    return markdown
def generate_example_value(attr_name, attr_schema, indent=0):
    # First check if this attribute is a nested object
    if "nested_type" in attr_schema:
        lines = [f'{"  " * indent}{attr_name} = {{']
        for nested_attr_name, nested_attr_schema in attr_schema["nested_type"]["attributes"].items():
            lines.append(generate_example_value(nested_attr_name, nested_attr_schema, indent + 1))
        lines.append(f'{"  " * indent}}}')
        return "\n".join(lines)

    # Otherwise, fall back to the simple types
    attr_type = attr_schema.get("type", "string")
    if attr_type == "string":
        return f'{"  " * indent}{attr_name} = "example string"'
    elif attr_type == "number":
        return f'{"  " * indent}{attr_name} = 123'
    elif attr_type == "bool":
        return f'{"  " * indent}{attr_name} = true'
    elif attr_type in ("list", "set"):
        # Check if the element type is nested:
        if "nested_type" in attr_schema.get("element_type", {}):
            lines = [f'{"  " * indent}{attr_name} = [']
            for i in range(2):
                lines.append(generate_example_value(
                    f"element_{i}",
                    attr_schema.get("element_type", {}),
                    indent + 1
                ))
            lines.append(f'{"  " * indent}]')
            return "\n".join(lines)
        else:
            element_type = attr_schema.get("element_type", {}).get("type", "string")
            if element_type == "string":
                return f'{"  " * indent}{attr_name} = ["item1", "item2"]'
            elif element_type == "number":
                return f'{"  " * indent}{attr_name} = [1, 2, 3]'
            elif element_type == "bool":
                return f'{"  " * indent}{attr_name} = [true, false]'
    elif attr_type == "map":
        return (f'{"  " * indent}{attr_name} = {{\n'
                f'{"  " * (indent + 1)}key1 = "value1"\n'
                f'{"  " * (indent + 1)}key2 = "value2"\n'
                f'{"  " * indent}}}')
    else:
        return f'{"  " * indent}{attr_name} = "value"'

# Function to generate a Markdown file for a resource or data source
# Function to generate a Markdown file for a resource or data source
def generate_markdown(file_path, name, description, attributes, is_resource=True):
    with open(file_path, "w") as f:
        # Title
        f.write(f"# {'Resource' if is_resource else 'Data Source'}: {name}\n\n")

        # Description
        f.write(f"## Description\n\n{description}\n\n")

        # Example Usage
        f.write("## Example Usage\n\n")
        f.write("```hcl\n")
        if is_resource:
            f.write(f'resource "{name}" "example" {{\n')
        else:
            f.write(f'data "{name}" "example" {{\n')
        # Write required attributes
        for attr_name, attr_schema in attributes.items():
            if attr_schema.get("required", False) or attr_schema.get("optional", False) or attr_schema.get("computed", False):
                f.write(generate_example_value(attr_name, attr_schema, indent=1) + "\n")
        f.write("}\n```\n\n")

        # Argument Reference
        f.write("## Argument Reference\n\n")
        f.write(process_attributes(attributes))

# Generate documentation for each provider
for provider_name, provider_schema in schema["provider_schemas"].items():
    # Generate resource documentation
    for resource_name, resource_schema in provider_schema["resource_schemas"].items():
        resources.append(resource_name)
        generate_markdown(
            file_path=f"docs/resources/{resource_name}.md",
            name=resource_name,
            description=resource_schema.get("description", "No description available."),
            attributes=resource_schema["block"]["attributes"],
            is_resource=True,
        )

    # Generate data source documentation
    for data_source_name, data_source_schema in provider_schema["data_source_schemas"].items():
        data_sources.append(data_source_name)
        generate_markdown(
            file_path=f"docs/data-sources/{data_source_name}.md",
            name=data_source_name,
            description=data_source_schema.get("description", "No description available."),
            attributes=data_source_schema["block"]["attributes"],
            is_resource=False,
        )

# Generate the index.md file
with open("docs/index.md", "w") as f:
    f.write(f"# Provider: {provider_name}\n\n")
    f.write("## Resources\n\n")
    for resource in resources:
        f.write(f"- [{resource}](resources/{resource}.md)\n")
    f.write("\n## Data Sources\n\n")
    for data_source in data_sources:
        f.write(f"- [{data_source}](data-sources/{data_source}.md)\n")
    with open("README.md", "r") as r:
        f.write(r.read()+"\n\n")